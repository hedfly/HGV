/* DSblock model generated by Dymola from Modelica model HGV.BaseClasses.Components.Examples.PumpConstantSpeed
 Dymola Version 2015 FD01 (64-bit), 2014-11-04 translated this at Fri Sep 18 11:17:48 2015

   */

#include <matrixop.h>
static double DymArrays0[1]={0.0};
static const char* DymArrays1[1]={"SimpleLiquidWater"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  RealArray   V_flow_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(RealArray    V_flow_02, 
  RealArray    eta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.V_flow_0member = V_flow_02;
  dummy_0.eta_0member = eta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMax(double  
  x10_0, double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der5, double  kx_0der5, double  mx_0flowx_0turbulentx_0der5);
DYMOLA_STATIC double   HGV_Buildings_Utilities_Math_Functions_spliceFunction(
  double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
discrete input Real V_flow(unit = "m3/s") "Volumetric flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete input Real r_N(unit = "1") "Relative revolution, r_N=N/N_nominal";
discrete input Real delta "Small value for switching implementation around zero rpm";
discrete output Real eta(unit = "1", min = 0.0) "Efficiency";
protected 
Integer n(start = size(per.V_flow, 1)) "Number of data points";
discrete Real rat "Ratio of V_flow/r_N";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := per.eta[1];
else
rat := V_flow/Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
i := 1;
for j in (1:n-1) loop
if (rat > per.V_flow[j]) then 
i := j;
end if;
end for;
eta := Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i+1], per.eta[i], per.eta[i+1], d[i], d[i+1]);
end if;
annotation(smoothOrder=1);
end Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0) {
  PushContext("Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    double   rat0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( per0_0.V_flow_0member, 1);
    rat0_0=0;
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealVectorElement( per0_0.eta_0member, (SizeType)(1));
      }
      else{
        rat0_0 = divmacro(Vx_0flow,"V_flow",Buildings_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)");
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rat0_0 > RealElement( per0_0.V_flow_0member, (SizeType)(j0_0_0)))
               {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
          (rat0_0, RealElement( per0_0.V_flow_0member, (SizeType)(i0_0)), 
          RealElement( per0_0.V_flow_0member, (SizeType)(i0_0+1)), RealElement( 
          per0_0.eta_0member, (SizeType)(i0_0)), RealElement( per0_0.eta_0member,
           (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)), 
          RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(smoothOrder=1);
end Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.smoothMax
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := Buildings.Utilities.Math.Functions.spliceFunction(x1, x2, x1-x2, deltaX);
annotation(smoothOrder=1);
end Buildings.Utilities.Math.Functions.smoothMax;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMax(double  
  x10_0, double  x20_0, double  deltaX0_0) {
  PushContext("Buildings.Utilities.Math.Functions.smoothMax")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = Buildings_Utilities_Math_Functions_spliceFunction(x10_0, x20_0, 
        x10_0-x20_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end Buildings.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("Buildings.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp
discrete input Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real k(min = 0.0) "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
protected 
discrete Real dp_turbulent(unit = "Pa", displayUnit = "Pa") "Turbulent flow if |dp| >= dp_small, not a parameter because k can be a function of time";
discrete Real kSqu(unit = "kg.m") "Flow coefficient, kSqu=k^2=m_flow^2/|dp|";
public 
algorithm 
kSqu := k*k;
dp_turbulent := m_flow_turbulent^2/kSqu;
m_flow := Modelica.Fluid.Utilities.regRoot2(dp, dp_turbulent, kSqu, kSqu, false, 1);
annotation(LateInline=true, smoothOrder=2);
end ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp;

  */
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   kSqu0_0;
    mx_0flow=0;
    dpx_0turbulent=0;
    kSqu0_0=0;
    /* Start of real code */
      kSqu0_0 = k0_0*k0_0;
      dpx_0turbulent = divmacro(sqr(mx_0flowx_0turbulent),"m_flow_turbulent^2",
        kSqu0_0,"kSqu");
      mx_0flow = Modelica_Fluid_Utilities_regRoot2(dp0_0, dpx_0turbulent, 
        kSqu0_0, kSqu0_0, false, 1);
    /* Output section */
    PopContext()
    return mx_0flow;
  }}

/* Flattened Modelica model:

function ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real kSquInv(unit = "1/(kg.m)") "Flow coefficient";
public 
algorithm 
kSquInv := 1/k^2;
dp := Modelica.Fluid.Utilities.regSquare2(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1);
annotation(derivative=ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf, LateInline=true, smoothOrder=2);
end ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    dp0_0=0;
    kSquInv0_0=0;
    /* Start of real code */
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dp0_0 = Modelica_Fluid_Utilities_regSquare2(mx_0flow, mx_0flowx_0turbulent,
         kSquInv0_0, kSquInv0_0, false, 1);
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf
discrete input Real m_flow;
discrete input Real k;
discrete input Real m_flow_turbulent;
protected 
discrete Real dp;
discrete Real kSquInv;
public 
discrete input Real m_flow_der5;
discrete input Real k_der5;
discrete input Real m_flow_turbulent_der5;
discrete output Real dp_der5;
protected 
discrete Real kSquInv_der5;
public 
algorithm 
kSquInv_der5 :=  -2.0*(k*k_der5)/(k^2)^2;
kSquInv := 1/k^2;
dp_der5 := Modelica.Fluid.Utilities.regSquare2:der(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1, m_flow_der5, m_flow_turbulent_der5, kSquInv_der5, kSquInv_der5, 0);
annotation(smoothOrder=1);
end ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf;

  */
DYMOLA_STATIC double   ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der5, double  kx_0der5, double  mx_0flowx_0turbulentx_0der5) {
  PushContext("ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    double   dpx_0der5;
    double   kSquInvx_0der5;
    dp0_0=0;
    kSquInv0_0=0;
    dpx_0der5=0;
    kSquInvx_0der5=0;
    /* Start of real code */
      kSquInvx_0der5 =  -divmacro(2.0*k0_0*kx_0der5,"2.0*(k*k_der5)",sqr(sqr(
        k0_0)),"(k^2)^2");
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dpx_0der5 = Modelica_Fluid_Utilities_regSquare2__der(mx_0flow, 
        mx_0flowx_0turbulent, kSquInv0_0, kSquInv0_0, false, 1, mx_0flowx_0der5,
         mx_0flowx_0turbulentx_0der5, kSquInvx_0der5, kSquInvx_0der5, 0);
    /* Output section */
    PopContext()
    return dpx_0der5;
  }}

/* Flattened Modelica model:

function HGV.Buildings.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=HGV.Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end HGV.Buildings.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   HGV_Buildings_Utilities_Math_Functions_spliceFunction(
  double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("HGV.Buildings.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)(i0_0_0)), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)(i0_0_0))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
discrete input Real k2(start = 1, min = 0.0) "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then sqrt(k1*x) else (if x <=  -x_small then  -sqrt(k2*abs(x)) else (if k1 >= k2 then Modelica.Fluid.Utilities.regRoot2.regRoot2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regRoot2.regRoot2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN sqrtGuarded(k10_0*x0_0,"k1*x") ELSE IF 
        x0_0 <=  -xx_0small THEN  -sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)")
         ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -
        Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility( -x0_0, xx_0small, 
        k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2.regRoot2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 >= k2";
discrete input Real k2 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|))";
input Boolean use_yd0 "= true, if yd0 shall be used";
discrete input Real yd0(min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real xsqrt1;
discrete Real xsqrt2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real y0d;
discrete Real w1;
discrete Real w2;
discrete Real sqrt_k1(start = (if k1 > 0 then sqrt(k1) else 0));
discrete Real sqrt_k2(start = (if k2 > 0 then sqrt(k2) else 0));
public 
algorithm 
if (k2 > 0) then 
x2 :=  -x1*(k2/k1);
elseif (k1 > 0) then 
x2 :=  -x1;
else
y := 0;
return;
end if;
if (x <= x2) then 
y :=  -sqrt_k2*sqrt(abs(x));
else
y1 := sqrt_k1*sqrt(x1);
y2 :=  -sqrt_k2*sqrt(abs(x2));
y1d := sqrt_k1/sqrt(x1)/2;
y2d := sqrt_k2/sqrt(abs(x2))/2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := sqrt_k1*sqrt(8.75/x1);
w2 := sqrt_k2*sqrt(8.75/abs(x2));
y0d := smooth(2, min(y0d, 0.9*min(w1, w2)));
y := y1*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1));
end if;
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2.regRoot2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2.regRoot2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   xsqrt10_0;
    double   xsqrt20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   y0d0_0;
    double   w10_0;
    double   w20_0;
    double   sqrtx_0k1;
    double   sqrtx_0k2;
    y0_0=0;
    x20_0=0;
    xsqrt10_0=0;
    xsqrt20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    y0d0_0=0;
    w10_0=0;
    w20_0=0;
    sqrtx_0k1 = IF k10_0 > 0 THEN sqrtGuarded(k10_0,"k1") ELSE 0;
    sqrtx_0k2 = IF k20_0 > 0 THEN sqrtGuarded(k20_0,"k2") ELSE 0;
    /* Start of real code */
      if (k20_0 > 0) {
        x20_0 =  -x10_0*divmacro(k20_0,"k2",k10_0,"k1");
      }
      else if (k10_0 > 0) {
        x20_0 =  -x10_0;
      }
      else{
        y0_0 = 0;
        goto returnTag;
      }
      if (x0_0 <= x20_0) {
        y0_0 =  -sqrtx_0k2*sqrtGuarded(fabs(x0_0),"abs(x)");
      }
      else{
        y10_0 = sqrtx_0k1*sqrtGuarded(x10_0,"x1");
        y20_0 =  -sqrtx_0k2*sqrtGuarded(fabs(x20_0),"abs(x2)");
        y1d0_0 = divmacro(sqrtx_0k1,"sqrt_k1",sqrtGuarded(x10_0,"x1"),"sqrt(x1)")
          /(double)(2);
        y2d0_0 = divmacro(sqrtx_0k2,"sqrt_k2",sqrtGuarded(fabs(x20_0),"abs(x2)"),
          "sqrt(abs(x2))")/(double)(2);
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = sqrtx_0k1*sqrtGuarded(divmacro(8.75,"8.75",x10_0,"x1"),"8.75/x1");
        w20_0 = sqrtx_0k2*sqrtGuarded(divmacro(8.75,"8.75",fabs(x20_0),"abs(x2)"),
          "8.75/abs(x2)");
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        y0_0 = y10_0*(IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1")) ELSE 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero(divmacro(
          x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), divmacro(y20_0,
          "y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,"y1"), divmacro
          (y0d0_0*x10_0,"y0d*x1",y10_0,"y1")));
      }
    returnTag:
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
discrete input Real k2(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then k1*x^2 else (if x <=  -x_small then  -k2*x^2 else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN k10_0*sqr(x0_0) ELSE IF x0_0 <=  -
        xx_0small THEN  -k20_0*sqr(x0_0) ELSE IF k10_0 >= k20_0 THEN 
        Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(x0_0, xx_0small,
         k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
discrete input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
algorithm 
x2 :=  -x1;
if (x <= x2) then 
y :=  -k2*x^2;
else
y1 := k1*x1^2;
y2 :=  -k2*x2^2;
y1d := k1*2*x1;
y2d :=  -k2*2*x2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := 2.23606797749979*k1*x1;
w2 := 2.23606797749979*k2*abs(x2);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d := ww;
end if;
y := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x2, y2, y2d, y0d));
end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    /* Start of real code */
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        y0_0 =  -k20_0*sqr(x0_0);
      }
      else{
        y10_0 = k10_0*sqr(x10_0);
        y20_0 =  -k20_0*sqr(x20_0);
        y1d0_0 = k10_0*2*x10_0;
        y2d0_0 =  -k20_0*2*x20_0;
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0d0_0 = ww0_0;
        }
        y0_0 = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2:der
discrete input Real x;
discrete input Real x_small(start = 0.01);
discrete input Real k1(start = 1);
discrete input Real k2(start = 1);
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x_small_der(start = 0.0);
discrete input Real k1_der(start = 0);
discrete input Real k2_der(start = 0);
discrete input Real yd0_der(start = 0);
discrete output Real y_der;

algorithm 
y_der := smooth(1, (if x >= x_small then k1_der*x^2+2.0*(k1*(x*x_der)) else (if x <=  -x_small then  -(k2_der*x^2+2.0*(k2*(x*x_der))) else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der(x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, yd0_der) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der( -x, x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN k1x_0der*sqr(x0_0)+2.0*k10_0*x0_0*
        xx_0der ELSE IF x0_0 <=  -xx_0small THEN  -(k2x_0der*sqr(x0_0)+2.0*k20_0
        *x0_0*xx_0der) ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
discrete input Real x "Value for which polynomial shall be evaluated";
discrete input Real x1 "Abscissa value";
discrete input Real y1 "y1=f(x1)";
discrete input Real y1d "First derivative at y1";
discrete input Real y0d "First derivative at f(x=0)";
discrete output Real y;
protected 
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
algorithm 
a1 := x1*y0d;
a2 := 3*y1-x1*y1d-2*a1;
a3 := y1-a2-a1;
xx := x/x1;
y := xx*(a1+xx*(a2+xx*a3));
annotation(derivative=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der, smoothOrder=3);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    /* Start of real code */
      a10_0 = x10_0*y0d0_0;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a30_0 = y10_0-a20_0-a10_0;
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      y0_0 = xx0_0*(a10_0+xx0_0*(a20_0+xx0_0*a30_0));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der
discrete input Real x;
discrete input Real x1;
discrete input Real k1;
discrete input Real k2;
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real k1_der;
discrete input Real k2_der;
discrete input Real yd0_der(start = 0);
discrete output Real y_der;
protected 
discrete Real x2_der;
discrete Real y1_der;
discrete Real y2_der;
discrete Real y1d_der;
discrete Real y2d_der;
discrete Real w_der;
discrete Real w1_der;
discrete Real w2_der;
discrete Real y0d_der;
discrete Real ww_der;
public 
algorithm 
x2_der :=  -x1_der;
x2 :=  -x1;
if (x <= x2) then 
y_der :=  -(k2_der*x^2+2.0*(k2*(x*x_der)));
else
y1_der := k1_der*x1^2+2.0*(k1*(x1*x1_der));
y1 := k1*x1^2;
y2_der :=  -(k2_der*x2^2+2.0*(k2*(x2*x2_der)));
y2 :=  -k2*x2^2;
y1d_der := 2.0*(k1_der*x1+k1*x1_der);
y1d := 2.0*(k1*x1);
y2d_der := (-2.0)*(k2_der*x2+k2*x2_der);
y2d := (-2.0)*(k2*x2);
if (use_yd0) then 
y0d_der := yd0_der;
y0d := yd0;
else
w_der := x2_der/x1-x2*x1_der/x1^2;
w := x2/x1;
y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-((3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2.0*(x1*(1-w)))-2.0*(((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der))/(2.0*(x1*(1-w)))^2;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2.0*(x1*(1-w)));
end if;
w1_der := 2.23606797749979*(k1_der*x1+k1*x1_der);
w1 := 2.23606797749979*(k1*x1);
w2_der := 2.23606797749979*(k2_der*abs(x2)+k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))));
w2 := 2.23606797749979*(k2*abs(x2));
ww_der := 0.9*(if w1 < w2 then w1_der else w2_der);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d_der := ww_der;
y0d := ww;
end if;
y_der := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x1, y1, y1d, y0d, x_der, x1_der, y1_der, y1d_der, y0d_der) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x2, y2, y2d, y0d, x_der, x2_der, y2_der, y2d_der, y0d_der));
end if;
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    double   yx_0der;
    double   x2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   w1x_0der;
    double   w2x_0der;
    double   y0dx_0der;
    double   wwx_0der;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    yx_0der=0;
    x2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    y0dx_0der=0;
    wwx_0der=0;
    /* Start of real code */
      x2x_0der =  -x1x_0der;
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        yx_0der =  -(k2x_0der*sqr(x0_0)+2.0*k20_0*x0_0*xx_0der);
      }
      else{
        y1x_0der = k1x_0der*sqr(x10_0)+2.0*k10_0*x10_0*x1x_0der;
        y10_0 = k10_0*sqr(x10_0);
        y2x_0der =  -(k2x_0der*sqr(x20_0)+2.0*k20_0*x20_0*x2x_0der);
        y20_0 =  -k20_0*sqr(x20_0);
        y1dx_0der = 2.0*(k1x_0der*x10_0+k10_0*x1x_0der);
        y1d0_0 = 2.0*k10_0*x10_0;
        y2dx_0der = (-2.0)*(k2x_0der*x20_0+k20_0*x2x_0der);
        y2d0_0 = (-2.0)*k20_0*x20_0;
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1.0,"1.0",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1.0,"1.0",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2.0*x10_0*helpvar[8];
          helpvar[10] = divmacro(1.0,"1.0",helpvar[9],"2.0*(x1*(1-w))");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1.0,"1.0",helpvar[15],"(2.0*(x1*(1-w)))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2.0*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2.0*
            x10_0*(1-w0_0),"2.0*(x1*(1-w))");
        }
        w1x_0der = 2.23606797749979*(k1x_0der*x10_0+k10_0*x1x_0der);
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w2x_0der = 2.23606797749979*(k2x_0der*fabs(x20_0)+k20_0*x2x_0der*(IF 
          x20_0 > 0 THEN 1 ELSE -1));
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        wwx_0der = 0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0dx_0der = wwx_0der;
          y0d0_0 = ww0_0;
        }
        yx_0der = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0, xx_0der, x1x_0der, y1x_0der, 
          y1dx_0der, y0dx_0der) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0, xx_0der, x2x_0der, y2x_0der, 
          y2dx_0der, y0dx_0der);
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der
discrete input Real x;
discrete input Real x1;
discrete input Real y1;
discrete input Real y1d;
discrete input Real y0d;
protected 
discrete Real y;
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real y1_der;
discrete input Real y1d_der;
discrete input Real y0d_der;
discrete output Real y_der;
protected 
discrete Real a1_der;
discrete Real a2_der;
discrete Real a3_der;
discrete Real xx_der;
public 
algorithm 
a1_der := x1_der*y0d+x1*y0d_der;
a1 := x1*y0d;
a2_der := 3*y1_der-(x1_der*y1d+x1*y1d_der)-2*a1_der;
a2 := 3*y1-x1*y1d-2*a1;
a3_der := y1_der-a2_der-a1_der;
a3 := y1-a2-a1;
xx_der := x_der/x1-x*x1_der/x1^2;
xx := x/x1;
y_der := xx_der*(a1+xx*(a2+xx*a3))+xx*(a1_der+xx_der*(a2+xx*a3)+xx*(a2_der+xx_der*a3+xx*a3_der));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    double   yx_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   a3x_0der;
    double   xxx_0der;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    yx_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    a3x_0der=0;
    xxx_0der=0;
    /* Start of real code */
      a1x_0der = x1x_0der*y0d0_0+x10_0*y0dx_0der;
      a10_0 = x10_0*y0d0_0;
      a2x_0der = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der)-2*a1x_0der;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a3x_0der = y1x_0der-a2x_0der-a1x_0der;
      a30_0 = y10_0-a20_0-a10_0;
      xxx_0der = divmacro(xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,
        "x*x1_der",sqr(x10_0),"x1^2");
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      yx_0der = xxx_0der*(a10_0+xx0_0*(a20_0+xx0_0*a30_0))+xx0_0*(a1x_0der+
        xxx_0der*(a20_0+xx0_0*a30_0)+xx0_0*(a2x_0der+xxx_0der*a30_0+xx0_0*
        a3x_0der));
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HGV.BaseClasses.Components.Examples.PumpConstantSpeed";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/dhe/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[6]={2 , 2 , 1 , 3 , 1 , 2};
DYMOLA_STATIC long QJacobianGC_[7]={
1 , 1 , 3 , 0 , 2 , 2 , 0};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 50 , 66};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = true;
W_[10] = 10;
W_[12] = 1;
W_[13] = 1;
W_[17] = true;
W_[22] = false;
W_[23] = 1;
W_[24] = 1;
W_[25] = 1;
W_[26] = 1;
W_[31] = false;
W_[33] = 2;
W_[37] = true;
W_[43] = 1;
W_[49] = false;
W_[55] = true;
W_[56] = false;
W_[61] = true;
W_[67] = false;
W_[68] = true;
W_[73] = false;
W_[100] = false;
W_[104] = true;
W_[108] = 1;
W_[109] = 1;
W_[110] = 2;
W_[113] = 2;
W_[116] = 2;
W_[117] = 0;
W_[118] = 0;
W_[119] = 2;
W_[132] = 2;
W_[153] = 3;
W_[154] = false;
W_[155] = false;
W_[156] = false;
W_[157] = false;
W_[164] = true;
W_[171] = true;
W_[174] = 10;
W_[177] = false;
W_[179] = 6000;
W_[183] = 10;
W_[184] = 6000;
W_[191] = true;
W_[197] = 10;
W_[200] = false;
W_[203] = 6000;
W_[207] = 10;
W_[208] = 6000;
W_[215] = 1;
W_[216] = 1;
W_[217] = 1;
W_[223] = false;
W_[224] = 2;
DYNSetAuxString("SimpleLiquidWater", 0);
W_[57] = 1;
W_[105] = 4;
W_[1] = 1;
W_[2] = 1;
W_[3] = 1;
W_[4] = 1;
W_[5] = 4;
W_[8] = false;
W_[11] = 10;
W_[14] = 1;
W_[15] = 1;
W_[16] = 1;
W_[19] = false;
W_[20] = 10.0;
W_[21] = 0.001;
W_[30] = 1;
W_[32] = 10.0;
W_[34] = 0.001;
W_[35] = true;
W_[53] = 1.0;
W_[46] = 995.586;
W_[54] = 0.010044335697769956;
W_[36] = 0.010044335697769956;
W_[42] = 995.586;
W_[44] = 300000.0;
W_[45] = 293.15;
W_[51] = 0;
W_[63] = false;
W_[64] = false;
W_[66] = 0.001;
W_[78] = false;
W_[79] = true;
W_[80] = 995.586;
W_[103] = 0.010044335697769956;
W_[96] = 1.0044335697769957E-005;
W_[102] = 300000;
W_[107] = -1;
W_[112] = 4;
W_[130] = 10.0;
W_[143] = true;
W_[144] = true;
W_[158] = 0;
W_[159] = 293.15;
W_[160] = 1;
W_[169] = 0;
W_[170] = 0;
W_[175] = 0.001;
W_[176] = true;
W_[178] = false;
W_[180] = false;
W_[190] = true;
W_[185] = false;
W_[182] = 0.001;
W_[186] = 1;
W_[187] = 4000;
W_[188] = 0.3;
W_[181] = 3.0;
W_[189] = 0.12909944487358058;
W_[198] = 0.001;
W_[199] = true;
W_[202] = false;
W_[204] = false;
W_[214] = true;
W_[209] = false;
W_[206] = 0.001;
W_[210] = 1;
W_[211] = 4000;
W_[212] = 0.3;
W_[205] = 3.0;
W_[213] = 0.12909944487358058;
W_[218] = 1;
W_[222] = 1.0;
W_[234] = true;
W_[235] = true;
W_[241] = 0.010044335697769956;
W_[252] = 995.586;
W_[247] = 4184;
W_[242] = 0.0;
W_[248] = 995.586;
W_[249] = false;
W_[250] = 300000.0;
W_[251] = 293.15;
W_[163] = 1.0;
W_[228] = 0;
W_[239] = 0.0;
W_[238] = 10.0;
W_[52] = 0;
W_[240] = 0.0;
W_[201] = 0.0;
W_[149] = 83680.0;
W_[74] = 0;
W_[138] = 1;
W_[139] = 0;
W_[145] = 20.0;
W_[146] = 0.0;
W_[230] = 1;
W_[231] = 0;
W_[237] = 0.0;
W_[173] = 0.0;
W_[193] = 0.0;
W_[195] = 0.0;
W_[59] = 0.0;
W_[18] = 0.0;
W_[62] = 0.0;
W_[70] = 0.0;
W_[60] = 995.586;
W_[50] = 0.0;
W_[243] = 0.0;
W_[244] = 0.0;
W_[232] = 0.018015268;
W_[229] = 995.586;
W_[233] = 0.0;
W_[225] = 0.0;
W_[226] = 0.0;
W_[40] = 0.0;
W_[41] = 0.0;
W_[38] = 0.0;
W_[39] = 0.0;
W_[126] = 0.0;
W_[166] = 83680.0;
W_[165] = 0.0;
W_[167] = 0.0;
W_[162] = 293.15;
W_[140] = 0.018015268;
W_[133] = 293.15;
W_[137] = 995.586;
W_[135] = 83680.0;
W_[134] = 0.0;
W_[142] = 293.15;
W_[141] = 0.0;
W_[136] = 83680.0;
W_[161] = 0.0;
W_[148] = 0.0;
W_[152] = 83680.0;
W_[151] = 0.0;
BoundParameterSection
AssertModelica(DP_[29] > 0,"pumCon.Pum.filter.A_ripple > 0", "A_ripple > 0 required");
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[27] = DP_[7];
W_[28] = DP_[8];
W_[29] = DP_[9];
W_[47] = W_[27];
W_[48] = W_[28];
W_[65] = DP_[26];
W_[75] = DP_[7];
W_[76] = DP_[8];
W_[77] = 4184*(W_[76]-273.15);
W_[88] = DP_[15];
W_[89] = DP_[16];
W_[90] = DP_[17];
W_[91] = DP_[18];
W_[92] = DP_[19];
W_[93] = DP_[20];
W_[94] = DP_[21];
W_[95] = DP_[22];
W_[111] = divmacro(5,"5",6.283185307179586*DP_[25],"6.283185307179586*pumCon.Pum.riseTime");
W_[114] = DP_[26];
W_[115] = fabs(DP_[27]);
W_[219] = W_[27];
W_[220] = W_[28];
W_[221] = W_[29];
W_[253] = 4184*(W_[220]-273.15);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 1. */
/* Introducing 5 common subexpressions used in 0 expressions */
/* Of the common subexpressions 5 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"dpDyn1.port_a.m_flow"};
const double nominal_[]={10.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 1, 2);
SetInitVectorSimple(x__, 1, W_[192], 0);
Residues;
helpvar[0] = (PushModelContext(1,"ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(dpDyn1.port_a.m_flow, 0.12909944487358058, 3.0)")
  ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (W_[192], 0.12909944487358058, 3.0));
PopModelContext();
helpvar[1] = homotopy(helpvar[0], 600.0*W_[192]);
SetVector(residue__, 1,  -helpvar[1]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1,  -homotopy((PushModelContext(1,
  "ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(dpDyn1.port_a.m_flow, 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)")
  ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
  (W_[192], 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)), 600.0));
PopModelContext();

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[192] = GetVector(x__, 1);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[58] = 288.15;
W_[71] = 293.15;
W_[72] = 293.15;
W_[101] = 1;
W_[125] = 0;
W_[128] = 300000;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[127] = W_[77];
W_[172] = W_[77];
W_[227] = W_[220];
InitialStartSection
Aux_[0] = W_[77];
Aux_[1] = W_[77];
Aux_[0] = W_[77];
Aux_[1] = W_[77];
InitialStartSection2
X_[2] = 41840.0*(W_[48]-273.15);
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
F_[0] = 0.0;
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[27] = DP_[7];
W_[28] = DP_[8];
W_[29] = DP_[9];
W_[47] = W_[27];
W_[48] = W_[28];
W_[65] = DP_[26];
W_[75] = DP_[7];
W_[76] = DP_[8];
W_[77] = 4184*(W_[76]-273.15);
W_[88] = DP_[15];
W_[89] = DP_[16];
W_[90] = DP_[17];
W_[91] = DP_[18];
W_[92] = DP_[19];
W_[93] = DP_[20];
W_[111] = divmacro(5,"5",6.283185307179586*DP_[25],"6.283185307179586*pumCon.Pum.riseTime");
AssertModelica(W_[111] > 0,"pumCon.Pum.filter.f_cut > 0", "f_cut > 0 required");
W_[114] = DP_[26];
W_[115] = fabs(DP_[27]);
AssertModelica(W_[115] > 0,"pumCon.Pum.filter.u_nominal > 0", "u_nominal > 0 required");
W_[219] = W_[27];
W_[220] = W_[28];
W_[221] = W_[29];
W_[253] = 4184*(W_[220]-273.15);
W_[94] = DP_[21];
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
W_[95] = DP_[22];
  RealAssign (RealTemporaryDense( &W_[97], 1, 1), RealConvertInteger (IF W_[95]
     THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
  RealAssign (RealTemporaryDense( &W_[98], 1, 1), RealConvertInteger (IF W_[95]
     THEN IntegerFill( 0, 1, (SizeType)(1)) ELSE IntegerTemporaryDense( 
    DymArrays0, 1, 1)));
  PopAllMarks();
RealAssign (RealTemporaryDense( &W_[120], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, pumCon.Pum.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[31])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(pumCon.Pum.filter.cr, pumCon.Pum.filter.c0, pumCon.Pum.filter.c1, pumCon.Pum.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[120], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[111]));
  RealAssign (RealTemporaryDense( &W_[122], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
if (DymolaHomotopyLambda==0){
  BreakSectionCall(2);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 2. */
  const char*const varnames_[]={"dpDyn1.port_a.m_flow"};
  const double nominal_[]={10.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 2, 3);
  SetInitVectorSimple(x__, 1, W_[192], 0);
  Residues;
  SetVector(residue__, 1,  -homotopy((PushModelContext(1,"ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(dpDyn1.port_a.m_flow, 0.12909944487358058, 3.0)")
    ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
    (W_[192], 0.12909944487358058, 3.0)), 600.0*W_[192]));
  PopModelContext();

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1,  -homotopy((PushModelContext(1,
    "ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(dpDyn1.port_a.m_flow, 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)")
    ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
    (W_[192], 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)), 600.0));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[192] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
   /* End of Non-Linear Equation Block */ }



}
W_[131] = DP_[35]+(IF LessTime(DP_[36], 0) THEN 0 ELSE DP_[34]);
W_[106] = 10.0*W_[131];
AssertModelica(GreaterEqual(W_[106],"pumCon.Pum.dp_in", -0.001,"-0.001", 0),
  "pumCon.Pum.dp_in >= -0.001", StringAdd("dp_in cannot be negative. Obtained dp_in = ",
  Real2String2(W_[106], true, 0)));
PopAllMarks();
W_[124] = divmacro(W_[106],"pumCon.Pum.dp_in",W_[115],"pumCon.Pum.filter.u_nominal");
 /* Linear system of equations to solve. */
X_[0] = 0.0;
SolveScalarLinearParametric( -W_[122]," -pumCon.Pum.filter.r[1]",  -W_[122]*
  W_[124]," -pumCon.Pum.filter.r[1]*pumCon.Pum.filter.uu[1]", X_[0],
  "pumCon.Pum.filter.x[1]");
 /* End of Equation Block */ 

W_[128] = W_[114];
 /* Linear system of equations to solve. */
X_[1] = 0.0;
SolveScalarLinearParametric( -DP_[28]*W_[115]," -pumCon.Pum.filter.gain*pumCon.Pum.filter.u_nominal",
    -W_[128]," -pumCon.port_b.p", X_[1],"pumCon.Pum.filter.x[2]");
 /* End of Equation Block */ 

X_[2] = 41840.0*(W_[48]-273.15);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(3);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 3. */
  const char*const varnames_[]={"pumCon.port_a.m_flow"};
  const double nominal_[]={10.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 3, 4);
  SetInitVectorSimple(x__, 1, W_[125], 0);
  Residues;
  SetVector(residue__, 1, W_[128]-homotopy((PushModelContext(1,"ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(pumCon.port_a.m_flow, 0.12909944487358058, 3.0)")
    ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
    (W_[125], 0.12909944487358058, 3.0)), 600.0*W_[125]));
  PopModelContext();

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1,  -homotopy((PushModelContext(1,
    "ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(pumCon.port_a.m_flow, 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)")
    ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
    (W_[125], 0.12909944487358058, 3.0, 1.0, 0.0, 0.0)), 600.0));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[125] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 3);
   /* End of Non-Linear Equation Block */ }



}
W_[87] = 0.0010044335697769957*W_[125];
W_[85] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumCon.Pum.per.hydraulicEfficiency, \npumCon.Pum.VMachine_flow, \npumCon.Pum.hydDer, \n1, \n0.0001)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[15], 1, 1), RealTemporaryDense( &DP_[16], 1, 1)), 
  W_[87], RealTemporaryDense( &W_[98], 1, 1), 1, 0.0001));
PopAllMarks();
W_[82] = W_[128]*W_[87];
 /* Linear system of equations to solve. */
W_[81] = 0.0;
SolveScalarLinear(W_[85],"pumCon.Pum.etaHyd", W_[82],"pumCon.Pum.WFlo", W_[81],
  "pumCon.Pum.WHyd");
 /* End of Equation Block */ 

W_[86] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumCon.Pum.per.motorEfficiency, \npumCon.Pum.VMachine_flow, \npumCon.Pum.motDer, \n1, \n0.0001)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[17], 1, 1), RealTemporaryDense( &DP_[18], 1, 1)), 
  W_[87], RealTemporaryDense( &W_[97], 1, 1), 1, 0.0001));
PopAllMarks();
W_[84] = W_[85]*W_[86];
W_[129] = divmacro(W_[82],"pumCon.Pum.WFlo",(PushModelContext(1,"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.eta, 1E-005, pumCon.Pum.eta-1E-005, 1E-006)")
  HGV_Buildings_Utilities_Math_Functions_spliceFunction(W_[84], 1E-005, W_[84]-
  1E-005, 1E-006)),"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.eta, 1E-005, pumCon.Pum.eta-1E-005, 1E-006)");
PopModelContext();
W_[99] = (IF W_[94] THEN W_[129] ELSE W_[81])-W_[82];
W_[83] = homotopy((PushModelContext(1,"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.QThe_flow, 0, noEvent(abs(pumCon.Pum.VMachine_flow))-2.0088671395539914E-005, 1.0044335697769957E-005)")
  HGV_Buildings_Utilities_Math_Functions_spliceFunction(W_[99], 0, fabs(W_[87])-
  2.0088671395539914E-005, 1.0044335697769957E-005)), 0);
PopModelContext();
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays1, 1, 1), true, true, RealTemporaryDense( &W_[163], 1, 1), 
  "Boundary_pT"));
PopAllMarks();

DynamicsSection
W_[131] = DP_[35]+(IF LessTime(DP_[36], 0) THEN 0 ELSE DP_[34]);
W_[106] = 10.0*W_[131];
AssertModelica(GreaterEqual(W_[106],"pumCon.Pum.dp_in", -0.001,"-0.001", 0),
  "pumCon.Pum.dp_in >= -0.001", StringAdd("dp_in cannot be negative. Obtained dp_in = ",
  Real2String2(W_[106], true, 0)));
PopAllMarks();
W_[124] = divmacro(W_[106],"pumCon.Pum.dp_in",W_[115],"pumCon.Pum.filter.u_nominal");
F_[0] = W_[122]*(X_[0]-W_[124]);
F_[1] = W_[123]*(X_[1]-X_[0]);
W_[128] = DP_[28]*W_[115]*X_[1];
/* Introducing 0 common subexpressions and reusing 1 variables totally used in 0
   expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */

Aux_[24] = W_[128];

W_[125] = (PushModelContext(1,"ChillerPlantSystem.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Nonlin_16., 0.12909944487358058, 3.0)")
  ChillerPlantSystem_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (Aux_[24], 0.12909944487358058, 3.0));
PopModelContext();

W_[147] =  -(W_[192]+W_[125]);
helpvar[2] = RealBmax( -W_[147], 0.0);
if (Init) {
helpvar[3] = RealBmax( -W_[192], 0.0);
}
Aux_[18] = helpvar[2]+helpvar[3];
Aux_[19] = IF Aux_[18] > 1E-010 THEN 1.0 ELSE IF Aux_[18] > 0.0 THEN sqr(
  10000000000.0*Aux_[18])*(3.0-20000000000.0*Aux_[18]) ELSE 0.0;
W_[150] = W_[125]+W_[192];
helpvar[4] = RealBmax( -W_[150], 0.0);
helpvar[5] = RealBmax(W_[125], 0.0);
Aux_[16] = helpvar[4]+helpvar[5];
Aux_[17] = IF Aux_[16] > 1E-010 THEN 1.0 ELSE IF Aux_[16] > 0.0 THEN sqr(
  10000000000.0*Aux_[16])*(3.0-20000000000.0*Aux_[16]) ELSE 0.0;
W_[127] = 0.1*X_[2];
helpvar[6] = 1.0-Aux_[17];
helpvar[7] = 1E-010*helpvar[6];
helpvar[8] = Aux_[17]*helpvar[4]+helpvar[7];
helpvar[9] = Aux_[17]*helpvar[5]+helpvar[7];
helpvar[10] = helpvar[8]+helpvar[9];
helpvar[11] = divmacro(1.0,"1.0",helpvar[10],"stream_alpha8*max( -sou.ports[2].m_flow, 0.0)+1E-010*(1.0-stream_alpha8)+stream_alpha8*max(pumCon.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha8)");
W_[194] = helpvar[11]*(83680.0*helpvar[8]+helpvar[9]*W_[127]);
helpvar[12] = 1.0-Aux_[19];
helpvar[13] = 1E-010*helpvar[12];
helpvar[14] = Aux_[19]*helpvar[2]+helpvar[13];
helpvar[15] = Aux_[19]*helpvar[3]+helpvar[13];
helpvar[16] = helpvar[14]+helpvar[15];
helpvar[17] = divmacro(1.0,"1.0",helpvar[16],"stream_alpha10*max( -sou.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha10)+stream_alpha10*max( -dpDyn1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha10)");
Aux_[4] = helpvar[17]*(83680.0*helpvar[14]+helpvar[15]*W_[194]);
Aux_[0] = Aux_[4];
Aux_[2] = Aux_[0];
Aux_[10] = Aux_[2];
W_[245] = W_[125]*(IF W_[125] > 0.0 THEN Aux_[10] ELSE W_[127]);
if (Init) {
helpvar[18] = RealBmax(W_[192], 0.0);
}
Aux_[14] = helpvar[4]+helpvar[18];
Aux_[15] = IF Aux_[14] > 1E-010 THEN 1.0 ELSE IF Aux_[14] > 0.0 THEN sqr(
  10000000000.0*Aux_[14])*(3.0-20000000000.0*Aux_[14]) ELSE 0.0;
helpvar[19] = RealBmax( -W_[125], 0.0);
Aux_[12] = helpvar[19]+helpvar[2];
Aux_[13] = IF Aux_[12] > 1E-010 THEN 1.0 ELSE IF Aux_[12] > 0.0 THEN sqr(
  10000000000.0*Aux_[12])*(3.0-20000000000.0*Aux_[12]) ELSE 0.0;
helpvar[20] = 1.0-Aux_[13];
helpvar[21] = 1E-010*helpvar[20];
helpvar[22] = Aux_[13]*helpvar[19]+helpvar[21];
helpvar[23] = Aux_[13]*helpvar[2]+helpvar[21];
helpvar[24] = helpvar[22]+helpvar[23];
helpvar[25] = divmacro(1.0,"1.0",helpvar[24],"stream_alpha4*max( -pumCon.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha4)+stream_alpha4*max( -sou.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha4)");
W_[196] = helpvar[25]*(helpvar[22]*W_[127]+83680.0*helpvar[23]);
helpvar[26] = 1.0-Aux_[15];
helpvar[27] = 1E-010*helpvar[26];
helpvar[28] = Aux_[15]*helpvar[4]+helpvar[27];
helpvar[29] = Aux_[15]*helpvar[18]+helpvar[27];
helpvar[30] = helpvar[28]+helpvar[29];
helpvar[31] = divmacro(1.0,"1.0",helpvar[30],"stream_alpha6*max( -sou.ports[2].m_flow, 0.0)+1E-010*(1.0-stream_alpha6)+stream_alpha6*max(dpDyn1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha6)");
W_[172] = helpvar[31]*(83680.0*helpvar[28]+helpvar[29]*W_[196]);
W_[246] =  -W_[125]*(IF  -W_[125] > 0.0 THEN W_[172] ELSE W_[127]);
F_[2] = W_[245]+W_[246];

AcceptedSection1
W_[227] = (-0.0002390057361376673)*((-1142859.5999999999)-W_[127]);
AssertModelica(GreaterEqual(W_[227],"pumCon.Pum.vol.dynBal.medium.T", 272.15,
  "272.15", 1) AND LessEqual(W_[227],"pumCon.Pum.vol.dynBal.medium.T", 403.15,
  "403.15", 2),"pumCon.Pum.vol.dynBal.medium.T >= 272.15 and pumCon.Pum.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(W_[227], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();

AcceptedSection2
Aux_[8] = W_[196];
Aux_[7] = W_[172];
Aux_[11] = W_[172];
Aux_[9] = W_[194];
Aux_[1] = W_[172];
Aux_[3] = W_[172];
Aux_[20] = helpvar[19]+helpvar[3];
Aux_[21] = IF Aux_[20] > 1E-010 THEN 1.0 ELSE IF Aux_[20] > 0.0 THEN sqr(
  10000000000.0*Aux_[20])*(3.0-20000000000.0*Aux_[20]) ELSE 0.0;
helpvar[32] = 1.0-Aux_[21];
helpvar[33] = 1E-010*helpvar[32];
helpvar[34] = Aux_[21]*helpvar[19]+helpvar[33];
helpvar[35] = Aux_[21]*helpvar[3]+helpvar[33];
helpvar[36] = helpvar[34]+helpvar[35];
helpvar[37] = divmacro(1.0,"1.0",helpvar[36],"stream_alpha12*max( -pumCon.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha12)+stream_alpha12*max( -dpDyn1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha12)");
Aux_[5] = helpvar[37]*(helpvar[34]*W_[127]+helpvar[35]*W_[194]);
Aux_[22] = helpvar[5]+helpvar[18];
Aux_[23] = IF Aux_[22] > 1E-010 THEN 1.0 ELSE IF Aux_[22] > 0.0 THEN sqr(
  10000000000.0*Aux_[22])*(3.0-20000000000.0*Aux_[22]) ELSE 0.0;
helpvar[38] = 1.0-Aux_[23];
helpvar[39] = 1E-010*helpvar[38];
helpvar[40] = Aux_[23]*helpvar[5]+helpvar[39];
helpvar[41] = Aux_[23]*helpvar[18]+helpvar[39];
helpvar[42] = helpvar[40]+helpvar[41];
helpvar[43] = divmacro(1.0,"1.0",helpvar[42],"stream_alpha14*max(pumCon.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha14)+stream_alpha14*max(dpDyn1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha14)");
W_[168] = helpvar[43]*(helpvar[40]*W_[127]+helpvar[41]*W_[196]);
Aux_[6] = W_[168];
W_[58] = 273.15+0.0002390057361376673*W_[127];
W_[69] = 0.0010044335697769957*W_[125];
W_[71] = 273.15+0.0002390057361376673*W_[127];
W_[72] = 273.15+0.0002390057361376673*W_[172];
W_[87] = 0.0010044335697769957*W_[125];
W_[85] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumCon.Pum.per.hydraulicEfficiency, \npumCon.Pum.VMachine_flow, \npumCon.Pum.hydDer, \n1, \n0.0001)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[15], 1, 1), RealTemporaryDense( &DP_[16], 1, 1)), 
  W_[87], RealTemporaryDense( &W_[98], 1, 1), 1, 0.0001));
PopAllMarks();
W_[82] = W_[128]*W_[87];
 /* Linear system of equations to solve. */
W_[81] = RememberSimple_(W_[81], 0);
SolveScalarLinear(W_[85],"pumCon.Pum.etaHyd", W_[82],"pumCon.Pum.WFlo", W_[81],
  "pumCon.Pum.WHyd");
 /* End of Equation Block */ 

W_[86] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumCon.Pum.per.motorEfficiency, \npumCon.Pum.VMachine_flow, \npumCon.Pum.motDer, \n1, \n0.0001)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[17], 1, 1), RealTemporaryDense( &DP_[18], 1, 1)), 
  W_[87], RealTemporaryDense( &W_[97], 1, 1), 1, 0.0001));
PopAllMarks();
W_[84] = W_[85]*W_[86];
helpvar[44] = (PushModelContext(1,"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.eta, 1E-005, pumCon.Pum.eta-1E-005, 1E-006)")
  HGV_Buildings_Utilities_Math_Functions_spliceFunction(W_[84], 1E-005, W_[84]-
  1E-005, 1E-006));
PopModelContext();
helpvar[45] = divmacro(1.0,"1.0",helpvar[44],"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.eta, 1E-005, pumCon.Pum.eta-1E-005, 1E-006)");
W_[129] = helpvar[45]*W_[82];
W_[99] = (IF W_[94] THEN W_[129] ELSE W_[81])-W_[82];
helpvar[46] = fabs(W_[87]);
W_[83] = (PushModelContext(1,"HGV.Buildings.Utilities.Math.Functions.spliceFunction(pumCon.Pum.QThe_flow, 0, noEvent(abs(pumCon.Pum.VMachine_flow))-2.0088671395539914E-005, 1.0044335697769957E-005)")
  HGV_Buildings_Utilities_Math_Functions_spliceFunction(W_[99], 0, helpvar[46]-
  2.0088671395539914E-005, 1.0044335697769957E-005));
PopModelContext();
W_[101] = 99.5586*W_[87];
W_[236] = W_[227]-273.15;

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", \
0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal",\
 4, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 5, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 6, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("m_flow_nominal", "[kg/s]", 10, 0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.m_flow_nominal", "Nominal mass flow rate  [kg/s]", 10, \
0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("pumCon.Pum.p_start", "Start value of pressure [Pa|bar]", 7, 300000,\
 0.0,100000000.0,100000.0,0,560)
DeclareParameter("pumCon.Pum.T_start", "Start value of temperature [K|degC]", 8,\
 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("pumCon.Pum.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 9, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("pumCon.Pum.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("pumCon.Pum.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pumCon.Pum.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 132)
DeclareVariable("pumCon.Pum.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("pumCon.Pum.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareAlias2("pumCon.Pum.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 132)
DeclareAlias2("pumCon.Pum.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumCon.port_b.p", 1, 5, 128, 4)
DeclareAlias2("pumCon.Pum.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareParameter("pumCon.Pum.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pumCon.Pum.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("pumCon.Pum.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumCon.Pum.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pumCon.Pum.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 0)
DeclareAlias2("pumCon.Pum.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 "pumCon.port_b.p", -1, 5, 128, 0)
DeclareVariable("pumCon.Pum.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pumCon.Pum.vol.p_start", "Start value of pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pumCon.Pum.vol.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,513)
DeclareVariable("pumCon.Pum.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("pumCon.Pum.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("pumCon.Pum.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,517)
DeclareVariable("pumCon.Pum.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pumCon.Pum.vol.V", "Volume [m3]", 0.010044335697769956, \
0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pumCon.Pum.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 132)
DeclareVariable("pumCon.Pum.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("pumCon.Pum.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareAlias2("pumCon.Pum.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 132)
DeclareVariable("pumCon.Pum.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("pumCon.Pum.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareAlias2("pumCon.Pum.vol.heatPort.T", "Port temperature [K|degC]", \
"pumCon.Pum.heatPort.T", 1, 5, 58, 4)
DeclareVariable("pumCon.Pum.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("pumCon.Pum.vol.T", "Temperature of the fluid [K|degC]", \
"pumCon.Pum.heatPort.T", 1, 5, 58, 0)
DeclareVariable("pumCon.Pum.vol.p", "Pressure of the fluid [Pa|bar]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("pumCon.Pum.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumCon.Pum.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.vol.state_start.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumCon.Pum.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumCon.Pum.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1024)
DeclareVariable("pumCon.Pum.vol.QSen_flow.y", "Value of Real output [W]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.masExc.k", "Constant output value [kg/s]", 0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.masExc.y", "Connector of Real output signal [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.tau", "Time constant at nominal flow [s]", 1.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.vol.V_nominal", "Volume of delay element [m3]", \
0.010044335697769956, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.dynamicBalance", "Set to true to use a dynamic balance, which often leads to smaller systems of equations [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pumCon.Pum.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pumCon.Pum.tau", "Time constant of fluid volume for nominal flow, used if dynamicBalance=true [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("pumCon.Pum.heatPort.T", "Port temperature [K|degC]", 288.15, \
0.0,1E+100,300.0,0,520)
DeclareVariable("pumCon.Pum.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("pumCon.Pum.rho_in", "Density of inflowing fluid [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.preSou.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumCon.Pum.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 1156)
DeclareVariable("pumCon.Pum.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("pumCon.Pum.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "dpDyn.port_a.h_outflow", 1, 5, 172, 1028)
DeclareAlias2("pumCon.Pum.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 1156)
DeclareAlias2("pumCon.Pum.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumCon.port_b.p", 1, 5, 128, 1028)
DeclareAlias2("pumCon.Pum.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1028)
DeclareVariable("pumCon.Pum.preSou.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.preSou.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pumCon.Pum.preSou.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 12, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pumCon.Pum.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareParameter("pumCon.Pum.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 13, 0, -100000.0,100000.0,0.0,0,2608)
DeclareVariable("pumCon.Pum.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumCon.Pum.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 1024)
DeclareAlias2("pumCon.Pum.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 "pumCon.port_b.p", -1, 5, 128, 1024)
DeclareVariable("pumCon.Pum.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumCon.Pum.preSou.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.preSou.state_a.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("pumCon.Pum.preSou.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 "pumCon.port_b.p", 1, 5, 128, 1024)
DeclareVariable("pumCon.Pum.preSou.state_b.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("pumCon.Pum.preSou.control_m_flow", "= false to control dp instead of m_flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumCon.Pum.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 "pumCon.port_b.p", -1, 5, 128, 1024)
DeclareVariable("pumCon.Pum.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.sta_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumCon.Pum.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pumCon.Pum.motorCooledByFluid", "If true (and if addPowerToMedium = true), then motor heat is added to fluid stream [:#(type=Boolean)]",\
 14, true, 0.0,0.0,0.0,0,562)
DeclareVariable("pumCon.Pum.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pumCon.Pum.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,513)
DeclareAlias2("pumCon.Pum.P", "Electrical power consumed [W]", "pumCon.P", 1, 5,\
 129, 0)
DeclareVariable("pumCon.Pum.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.Pum.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.Pum.Q_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.Pum.eta", "Global efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("pumCon.Pum.etaHyd", "Hydraulic efficiency [1]", 0.0, 0.0,1.0,\
0.0,0,512)
DeclareVariable("pumCon.Pum.etaMot", "Motor efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("pumCon.Pum.dpMachine", "Pressure increase [Pa|Pa]", \
"pumCon.port_b.p", 1, 5, 128, 0)
DeclareVariable("pumCon.Pum.VMachine_flow", "Volume flow rate [m3/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.Pum._perPow.hydraulicEfficiency.V_flow[1]", \
"Volumetric flow rate at user-selected operating points [m3/s]", 0.0, 0.0,1E+100,\
0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.hydraulicEfficiency.eta[1]", \
"Fan or pump efficiency at these flow rates [|1]", 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum._perPow.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum._perPow.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 1.0044335697769957E-005, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.motDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.hydDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.QThe_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumCon.Pum.control_m_flow", "= false to control head instead of m_flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pumCon.Pum.per.hydraulicEfficiency.V_flow[1]", \
"Volumetric flow rate at user-selected operating points [m3/s]", 15, 0, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("pumCon.Pum.per.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 16, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("pumCon.Pum.per.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 17, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumCon.Pum.per.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 18, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("pumCon.Pum.per.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 19, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumCon.Pum.per.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 20, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumCon.Pum.per.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 21, true, 0.0,0.0,0.0,0,562)
DeclareParameter("pumCon.Pum.per.use_powerCharacteristic", "Use powerCharacteristic instead of efficiencyCharacteristic [:#(type=Boolean)]",\
 22, false, 0.0,0.0,0.0,0,562)
DeclareVariable("pumCon.Pum.r_V", "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal) [1]",\
 1, 0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.Pum.p_a_default", "Nominal inlet pressure for predefined fan or pump characteristics [Pa|Pa]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.V_flow_max", "Maximum volume flow rate [m3/s]", \
0.010044335697769956, 0.0,0.0,0.0,0,2561)
DeclareParameter("pumCon.Pum.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 23, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("pumCon.Pum.sta_default.T", "Temperature of medium [K|degC]", 24,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("pumCon.Pum.filteredSpeed", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pumCon.Pum.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 25, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("pumCon.Pum.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("pumCon.Pum.dp_start", "Initial value of pressure raise [Pa|Pa]",\
 26, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumCon.Pum.dp_nominal", "Nominal pressure raise, used to normalize filter [Pa|Pa]",\
 27, 10000, 0.0,1E+100,0.0,0,560)
DeclareVariable("pumCon.Pum.dp_in", "Prescribed pressure rise [Pa]", 0.0, 0.0,\
1E+100,0.0,0,640)
DeclareAlias2("pumCon.Pum.dp_actual", "[Pa]", "pumCon.port_b.p", 1, 5, 128, 0)
DeclareVariable("pumCon.Pum.gain.k", "Gain value multiplied with input signal [1]",\
 -1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumCon.Pum.gain.u", "Input signal connector [Pa]", \
"pumCon.port_b.p", 1, 5, 128, 1024)
DeclareAlias2("pumCon.Pum.gain.y", "Output signal connector [Pa]", \
"pumCon.port_b.p", -1, 5, 128, 1024)
DeclareAlias2("pumCon.Pum.filter.u", "Connector of Real input signal [Pa]", \
"pumCon.Pum.dp_in", 1, 5, 106, 1024)
DeclareAlias2("pumCon.Pum.filter.y", "Connector of Real output signal [Pa]", \
"pumCon.port_b.p", 1, 5, 128, 1024)
DeclareVariable("pumCon.Pum.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.order", "Order of filter [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.f_cut", "Cut-off frequency [Hz]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("pumCon.Pum.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 28, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumCon.Pum.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 29, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumCon.Pum.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 30, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumCon.Pum.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 31, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pumCon.Pum.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("pumCon.Pum.filter.x_start[1]", "Initial or guess values of states",\
 32, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumCon.Pum.filter.x_start[2]", "Initial or guess values of states",\
 33, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("pumCon.Pum.filter.y_start", "Initial value of output [Pa]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.filter.u_nominal", "Nominal value of input (used for scaling the states) [Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareState("pumCon.Pum.filter.x[1]", "Filter states", 0, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pumCon.Pum.filter.der(x[1])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareState("pumCon.Pum.filter.x[2]", "Filter states", 1, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pumCon.Pum.filter.der(x[2])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("pumCon.Pum.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.filter.uu[1]", "", 0.0, 0.0,0.0,0.0,0,2688)
DeclareAlias2("pumCon.Pum.filter.uu[2]", "", "pumCon.Pum.filter.x[1]", 1, 1, 0, 1024)
DeclareAlias2("pumCon.Pum.filter.uu[3]", "", "pumCon.Pum.filter.x[2]", 1, 1, 1, 1024)
DeclareAlias2("pumCon.Pum.dp_filtered", "Filtered pressure [Pa]", \
"pumCon.port_b.p", 1, 5, 128, 1024)
DeclareVariable("pumCon.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,10.0,0,840)
DeclareVariable("pumCon.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("pumCon.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("pumCon.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 132)
DeclareVariable("pumCon.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("pumCon.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareVariable("pumCon.P", "Electrical power consumed by pump [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pumCon.gain.k", "Gain value multiplied with input signal [1]", \
10.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pumCon.gain.u", "Input signal connector", "pumCon.On", 1, 5, 131,\
 0)
DeclareAlias2("pumCon.gain.y", "Output signal connector [Pa]", "pumCon.Pum.dp_in", 1,\
 5, 106, 0)
DeclareVariable("pumCon.On", "On signal", 0.0, 0.0,1.0,0.0,0,640)
DeclareVariable("sou.nPorts", "Number of ports [:#(type=Integer)]", 2, 0.0,0.0,\
0.0,0,517)
DeclareVariable("sou.medium.T", "Temperature of medium [K|degC]", 293.15, 0.0,\
1E+100,300.0,0,513)
DeclareVariable("sou.medium.p", "Absolute pressure of medium [Pa|bar]", 0.0, 0.0,\
1E+100,100000.0,0,513)
DeclareVariable("sou.medium.h", "Specific enthalpy of medium [J/kg]", 83680.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("sou.medium.u", "Specific internal energy of medium [J/kg]", \
83680.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sou.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("sou.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [1]",\
 1, 0.0,1.0,0.0,0,513)
DeclareVariable("sou.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("sou.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.0,1E+100,0.0,0,513)
DeclareVariable("sou.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
0.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("sou.medium.state.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,513)
DeclareVariable("sou.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("sou.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("sou.medium.T_degC", "Temperature of medium in [degC] [degC;]", \
20.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sou.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sou.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -1E+060,1E+060,0.0,0,776)
DeclareVariable("sou.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("sou.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sou.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -1E+060,100000.0,0.0,0,776)
DeclareVariable("sou.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("sou.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sou.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("sou.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou.p", "Fixed value of pressure [Pa|bar]", 0, 0.0,100000000.0,\
100000.0,0,513)
DeclareVariable("sou.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("sou.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,0.1,\
0,513)
DeclareVariable("sou.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou.T_in_internal", "Needed to connect to conditional connector [K]",\
 293.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("On.height", "Height of step", 34, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("On.y", "Connector of Real output signal", "pumCon.On", 1, 5, 131,\
 0)
DeclareParameter("On.offset", "Offset of output signal y", 35, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("On.startTime", "Output y = offset for time < startTime [s]", 36,\
 20, 0.0,0.0,0.0,0,560)
DeclareVariable("senMasFlo.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("senMasFlo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[2].m_flow", 1, 5, 150, 132)
DeclareVariable("senMasFlo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("senMasFlo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareAlias2("senMasFlo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou.ports[2].m_flow", -1, 5, 150, 132)
DeclareVariable("senMasFlo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("senMasFlo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("senMasFlo.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 37, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("senMasFlo.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 38, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("senMasFlo.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 39, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("senMasFlo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("senMasFlo.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("senMasFlo.m_flow", "Mass flow rate from port_a to port_b [kg/s]",\
 "sou.ports[2].m_flow", 1, 5, 150, 0)
DeclareVariable("dpDyn.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("dpDyn.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 132)
DeclareAlias2("dpDyn.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumCon.port_b.p", 1, 5, 128, 4)
DeclareVariable("dpDyn.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("dpDyn.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 132)
DeclareVariable("dpDyn.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,300000.0,0,521)
DeclareAlias2("dpDyn.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 4)
DeclareParameter("dpDyn.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 40, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("dpDyn.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 41, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("dpDyn.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 42, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("dpDyn.m_flow_nominal", "Nominal mass flow rate [kg/s]", 10, \
0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("dpDyn.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dpDyn.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 0)
DeclareAlias2("dpDyn.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 "pumCon.port_b.p", 1, 5, 128, 0)
DeclareVariable("dpDyn.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 3.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("dpDyn.sta_default.p", "Absolute pressure of medium [Pa|bar]", 43,\
 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("dpDyn.sta_default.T", "Temperature of medium [K|degC]", 44, \
293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("dpDyn.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("dpDyn.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("dpDyn.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("dpDyn.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("dpDyn.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("dpDyn.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.12909944487358058, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("dpDyn1.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -1E+060,100000.0,10.0,0,841)
DeclareVariable("dpDyn1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,300000.0,0,521)
DeclareVariable("dpDyn1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("dpDyn1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "dpDyn1.port_a.m_flow", -1, 5, 192, 132)
DeclareVariable("dpDyn1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,300000.0,0,521)
DeclareVariable("dpDyn1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("dpDyn1.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 45, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("dpDyn1.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 46, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("dpDyn1.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 47, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("dpDyn1.m_flow_nominal", "Nominal mass flow rate [kg/s]", 10, \
0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn1.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("dpDyn1.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn1.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dpDyn1.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "dpDyn1.port_a.m_flow", 1, 5, 192, 0)
DeclareVariable("dpDyn1.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,6000.0,0,513)
DeclareVariable("dpDyn1.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn1.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 6000, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn1.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn1.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 3.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("dpDyn1.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 48, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("dpDyn1.sta_default.T", "Temperature of medium [K|degC]", 49, \
293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("dpDyn1.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("dpDyn1.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("dpDyn1.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 6000, 0.0,0.0,0.0,0,2561)
DeclareVariable("dpDyn1.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dpDyn1.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn1.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("dpDyn1.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("dpDyn1.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.12909944487358058, 0.0,0.0,0.0,0,513)
DeclareVariable("dpDyn1.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumCon.Pum.vol.dynBal.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.mSenFac", "Factor for scaling the sensible thermal mass of the volume [1]",\
 1.0, 1.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("pumCon.Pum.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareAlias2("pumCon.Pum.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", 1, 5, 125, 1156)
DeclareVariable("pumCon.Pum.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("pumCon.Pum.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1028)
DeclareAlias2("pumCon.Pum.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pumCon.port_a.m_flow", -1, 5, 125, 1156)
DeclareVariable("pumCon.Pum.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("pumCon.Pum.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1028)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.T", "Temperature of medium [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 0, 0.0,1E+100,100000.0,0,2561)
DeclareAlias2("pumCon.Pum.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1024)
DeclareAlias2("pumCon.Pum.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1024)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [1]",\
 1, 0.0,1.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,2561)
DeclareAlias2("pumCon.Pum.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "pumCon.Pum.vol.dynBal.medium.T", 1, 5, 227, 1024)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumCon.Pum.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareState("pumCon.Pum.vol.dynBal.U", "Internal energy of fluid [J]", 2, 0.0, \
0.0,0.0,0.0,0,2592)
DeclareDerivative("pumCon.Pum.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumCon.Pum.vol.dynBal.m", "Mass of fluid [kg]", 10.0, 0.0,\
1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumCon.Pum.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 "pumCon.Pum.vol.dynBal.der(U)", 1, 6, 2, 1024)
DeclareVariable("pumCon.Pum.vol.dynBal.fluidVolume", "Volume [m3]", \
0.010044335697769956, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.CSen", "Aditional heat capacity for implementing mFactor [J/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumCon.Pum.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "pumCon.port_a.h_outflow", 1, 5, 127, 1024)
DeclareVariable("pumCon.Pum.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("pumCon.Pum.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("pumCon.Pum.vol.dynBal.cp_default", "Heat capacity, to compute additional dry mass [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.computeCSen", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,2563)
DeclareVariable("pumCon.Pum.vol.dynBal.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumCon.Pum.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumCon.Pum.preSou.dp_in", "Prescribed outlet pressure [Pa]", \
"pumCon.port_b.p", -1, 5, 128, 1024)
EndNonAlias(0)
#define NX_    3
#define NX2_   3
#define NU_    0
#define NY_    0
#define NW_    254
#define NP_    50
#define NPS_   0
#define MAXAuxStr_   1
#define MAXAuxStrLen_   500
#define NHash1_ 1091333374
#define NHash2_ -774808179
#define NHash3_ 0
#define NI_    0
#define NRelF_ 3
#define NRel_  3
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    59
#define SizePre_ 0
#define SizeEq_ 1
#define SizeDelay_ 0
#define QNLmax_ 3
#define MAXAux 25
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 47
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[3];
if (HReject) W_[192]=initStore[0]; else initStore[0]=W_[192];
if (HReject) W_[125]=initStore[1]; else initStore[1]=W_[125];
}
StartDataBlock
StartEqBlock
DoRemember_(W_[81], 0.0, 0);
EndEqBlock
EndDataBlock
  BreakSectionStart(2);
  W_[192] = 0.0;
  BreakSectionEnd()
  BreakSectionStart(3);
  W_[125] = 0.0016666666666666668*W_[128];
  BreakSectionEnd()
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
